from functools import wraps
from .hellolan import *
from .ssh import *

PRESETS = {
    'ssh': 22, 'web': '80,443',
}

def main():
    '''Hellolan CLI'''
    import fire
    fire.Fire({
        'get': partial(getall, n=1),
        'getall': getall,
        'scan': _gentable(scan),
        **{k: _gentable(get_preset(k)) for k in PRESETS},
        'ssh-': ssh_into,
        'hostname': hostname,
        'me': me,
    })

def ssh_main():
    '''SSH Into CLI'''
    import fire
    fire.Fire(ssh_into)


def getall(col, hostname=None, preset=None, *a, **kw):
    return [d[col] for d in get_preset(preset)(hostname, *a, **kw)]


def get_preset(name):
    if name not in PRESETS:
        return scan
    kw = PRESETS[name]
    return partial(scan, **(kw if isinstance(kw, dict) else {'port': kw}))


def _loop(n):
    if n:
        yield from range(n)
    else:
        i = 0
        while True:
            yield i
            i += 1

def _dict_update(prev, new):
    prev, new = prev or {}, new or {}
    return dict(prev, **{k: new[k] or prev.get(k) for k in new})

def _dict_drop(d, *keys):
    return {k: v for k, v in d.items() if k not in keys}

def _gentable(func):
    '''Will print out rows of a table as they are generated by func(*a, **kw).
    I've found out that it's not super necessary because nmap.PortScanner
    yields most things toward the end anyways. So I may end up removing reprint.
    '''
    import time
    import functools
    import itertools
    from tabulate import tabulate

    # def _watch(disp, *a, headers=None, times=None, timer=True, **kw):
    def watchable(disp):
        @functools.wraps(disp)
        def outer(*a, watch=False, headers=None, times=None, timer=True, **kw):
            if not watch:
                # return _watch((lambda data: disp(data, headers)), *a, times=times, timer=timer, **kw)
                result = func(*a, **kw)
                print(disp(list(result), headers=headers))
                return result

            import datetime
            import reprint
            items = {}
            with reprint.output() as out:
                try:
                    out.append('Starting scan...')
                    for i in _loop(times):
                        t0 = time.time()
                        j = 0
                        for j, x in enumerate(func(*a, **kw)):
                            items[x['ip']] = _dict_update(items.get(x['ip']), x)
                        out.change(disp(list(items.values()), headers).splitlines())
                        if timer:
                            out.append('Scan {} finished at {}. took {:.1f}s. Found {} hosts.'.format(
                                i+1, datetime.datetime.now().strftime('%c'),
                                time.time() - t0, len(items)))
                except KeyboardInterrupt:
                    out.change(disp(list(items.values())).splitlines())
            return list(items.values())
        return outer

    @watchable
    def table(items, headers=None, sort='ip'):
        if isinstance(items, dict):
            items = list(items.values())
        if not headers and items and isinstance(items[0], dict):
            headers = 'keys'
        if sort:
            items = sorted(items, key=lambda x: natsort_key(x[sort]))
        return tabulate(items, headers=headers or ())

    @watchable
    def parseable(data, headers=None):
        headers = headers or set().union(*(d.keys() for d in data))
        return '\n'.join([
            '\t'.join(str(d.get(c)) or '' for c in headers)
            for d in data
        ])

    @watchable
    def as_json(data, headers=None):
        import json
        headers = headers or len(data) and data[0].keys() or ()
        data = ([d[headers[0]] for d in data] if len(headers) == 1 else
                [{c: d[c] for c in headers} for d in data])
        return json.dumps(data, indent=4)

    def save_json(out, result, inventory=None):
        import json
        with open(out, 'w') as f:
            if inventory:
                if isinstance(inventory, str):
                    inventory = inventory.split('&')
                inventory = (i.split('=') for i in inventory)
                res = {
                    group: [x['ip'] for x in result if matches(x, pat)]
                    for group, pat in inventory
                }
            else:
                res = {
                    d['ip']: _dict_drop(d, 'ip', 'ports') for d in result
                }
            json.dump(res, f)

    @functools.wraps(func)
    def inner(*a, headers=None, iplist=False, tab=False, timer=True, json=False, out=None, inventory=None, **kw):
        t0 = time.time()
        if iplist:
            headers, tab = (headers or ('ip',)), True
        if json:
            result = as_json(*a, headers=headers, timer=timer, **kw)
        elif tab:
            result = parseable(*a, headers=headers, timer=timer, **kw)
        else:
            result = table(*a, headers=headers, timer=timer, **kw)
        if out:
            save_json(out, result, inventory=inventory)
        if timer and not tab and not json:
            print('-')
            print('Took {:.1f} seconds'.format(time.time() - t0))
    return inner

def partial(func, *a, **kw):
    '''functools.partial doesn't apply wraps ???? wtf ??? it's right there......'''
    return wraps(func)(lambda *ai, **kwi: func(*a, *ai, **kw, **kwi))

import re
def natsort_key(s, _nsre=re.compile('([0-9]+)')):
    return tuple(int(t) if t.isdigit() else t.lower() for t in _nsre.split(s))


if __name__ == '__main__':
    main()
