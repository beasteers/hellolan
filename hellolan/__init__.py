from functools import wraps
from .hellolan import *
from .ssh import *

PRESETS = {
    'ssh': 22, 'web': '80,443',
}

def main():
    '''Hellolan CLI'''
    import fire
    fire.Fire({
        'get': partial(getall, n=1),
        'getall': getall,
        'scan': _gentable(scan),
        **{k: _gentable(get_preset(k)) for k in PRESETS},
        'ssh-': ssh_into,
        'hostname': hostname,
    })

def ssh_main():
    '''SSH Into CLI'''
    import fire
    fire.Fire(ssh_into)


def getall(col, hostname=None, preset=None, *a, **kw):
    return [d[col] for d in get_preset(preset)(hostname, *a, **kw)]


def get_preset(name):
    if name not in PRESETS:
        return scan
    kw = PRESETS[name]
    return partial(scan, **(kw if isinstance(kw, dict) else {'port': kw}))


def _gentable(func):
    '''Will print out rows of a table as they are generated by func(*a, **kw).
    I've found out that it's not super necessary because nmap.PortScanner
    yields most things toward the end anyways. So I may end up removing reprint.
    '''
    import time
    import functools
    from tabulate import tabulate

    def table(items, headers=None):
        if not headers and items and isinstance(items[0], dict):
            headers = 'keys'
        return tabulate(items, headers=headers or ())

    def allatonce(*a, headers=None, **kw):
        print(table(list(func(*a, **kw)), headers))

    # def asavailable(*a, headers=None, **kw):
    #     import reprint
    #     with reprint.output(interval=0.3) as out:
    #         items = []
    #         for x in func(*a, **kw):
    #             items.append(x)
    #             out.change(table(items, headers).splitlines())

    def parseable(*a, headers=None, **kw):
        data = list(func(*a, **kw))
        headers = headers or set().union(d.keys() for d in data)
        print('\n'.join([
            '\t'.join([d.get(c) or '' for c in headers])
            for d in data
        ]))

    def as_json(*a, headers=None, **kw):
        import json
        data = list(func(*a, **kw))
        headers = headers or len(data) and data[0].keys() or ()
        data = ([d[headers[0]] for d in data] if len(headers) == 1 else
                [{c: d[c] for c in headers} for d in data])
        print(json.dumps(data))

    @functools.wraps(func)
    def inner(*a, headers=None, ip=False, tab=False, timer=True, json=False, **kw):
        t0 = time.time()
        if ip:
            headers, tab = ('ip',), True
        if json:
            as_json(*a, headers=headers, **kw)
        elif tab:
            parseable(*a, headers=headers, **kw)
        else:
            # asavailable(*a, headers=headers, **kw)
            allatonce(*a, headers=headers, **kw)
        if timer and not tab and not json:
            print('-')
            print('Took {:.1f} seconds'.format(time.time() - t0))
    return inner

def partial(func, *a, **kw):
    '''functools.partial doesn't apply wraps ???? wtf ??? it's right there......'''
    return wraps(func)(lambda *ai, **kwi: func(*a, *ai, **kw, **kwi))


if __name__ == '__main__':
    main()
