from functools import wraps
from .hellolan import *

PRESETS = {
    'ssh': 22, 'web': '80,443',
}

def main():
    import fire
    fire.Fire({
        'get': _wrap(getall, n=1),
        'getall': getall,
        'scan': _gentable(scan),
        **{k: _gentable(get_preset(k)) for k in PRESETS},
        'ssh-': ssh_into,
    })


def getall(col, hostname=None, preset=None, *a, **kw):
    return [d[col] for d in get_preset(preset)(hostname, *a, **kw)]


def ssh_into(hostname, *a, user=None, i=None, sshargs=None, port=None, **kw):
    from subprocess import call

    hostname, user, port = _parse_hostname(hostname, user, port)
    hosts = list(scan(hostname, *a, port=port or 22, **kw))
    host = _resolve_multiple_hosts(hosts, i)

    if not host:
        return

    cmd = 'ssh {} {}'.format(_build_hoststr(host['ip'], user, port), sshargs or '').strip()

    print('''
---------------------
Starting SSH Session: $ {cmd}
---------------------
'''.format(cmd=cmd))
    call(cmd, shell=True)
    print('''
-------------------
Ended SSH Session. ({cmd})
-------------------
'''.format(cmd=cmd))




def _parse_hostname(hostname, user=None, port=None):
    if not user:
        user, hostname = hostname.split('@') if '@' in hostname else (hostname, None)
    if not port:
        hostname, port = hostname.split(':') if ':' in hostname else (hostname, None)
    return hostname, user, port

def _build_hoststr(hostname, user, port):
    if user:
        hostname = '{}@{}'.format(user, hostname)
    if port:
        hostname = '{} -p {}'.format(hostname, port)
    return hostname

def _resolve_multiple_hosts(hosts, i=None):
    print()
    # select which host to connect to
    if not hosts:
        print('No hosts found.')
        return

    if len(hosts) > 1: # by default, ask for multiple
        from tabulate import tabulate
        print('Multiple hosts found:')
        print(tabulate(hosts, headers='keys', showindex=True))
        print()

        if i is None:
            i = int(input('Which host to use? [0]: ').strip() or 0)
    else:
        i = 0

    host = hosts[i or 0]
    print('Using host: {}'.format(host['hostname']))
    return host




def _wrap(func, *a, **kw):
    '''functools.partial doesn't apply wraps ???? wtf ???
    it's right there......'''
    return wraps(func)(
        lambda *ai, **kwi: func(*a, *ai, **kw, **kwi))


def get_preset(name):
    if name not in PRESETS:
        return scan
    kw = PRESETS[name]
    return _wrap(scan, **(kw if isinstance(kw, dict) else {'port': kw}))

def _gentable(func):
    '''Will print out rows of a table as they are generated by func(*a, **kw).
    I've found out that it's not super necessary because nmap.PortScanner
    yields most things toward the end anyways. So I may end up removing reprint.
    '''
    import time
    import functools
    from tabulate import tabulate

    def table(items, headers=None):
        if not headers and items and isinstance(items[0], dict):
            headers = 'keys'
        return tabulate(items, headers=headers or ())

    def allatonce(*a, headers=None, **kw):
        print(table(list(func(*a, **kw)), headers))

    def asavailable(*a, headers=None, **kw):
        import reprint
        with reprint.output(interval=0.3) as out:
            items = []
            for x in func(*a, **kw):
                items.append(x)
                out.change(table(items, headers).splitlines())

    def parseable(*a, headers=None, **kw):
        data = list(func(*a, **kw))
        headers = headers or set().union(d.keys() for d in data)
        print('\n'.join([
            '\t'.join([d.get(c) or '' for c in headers])
            for d in data
        ]))

    def as_json(*a, headers=None, **kw):
        import json
        data = list(func(*a, **kw))
        headers = headers or len(data) and data[0].keys() or ()
        data = ([d[headers[0]] for d in data] if len(headers) == 1 else
                [{c: d[c] for c in headers} for d in data])
        print(json.dumps(data))

    @functools.wraps(func)
    def inner(*a, headers=None, ip=False, tab=False, timer=True, json=False, **kw):
        t0 = time.time()
        if ip:
            headers, tab = ('ip',), True
        if json:
            as_json(*a, headers=headers, **kw)
        elif tab:
            parseable(*a, headers=headers, **kw)
        else:
            # asavailable(*a, headers=headers, **kw)
            allatonce(*a, headers=headers, **kw)
        if timer and not tab and not json:
            print('-')
            print('Took {:.1f} seconds'.format(time.time() - t0))
    return inner




if __name__ == '__main__':
    main()
